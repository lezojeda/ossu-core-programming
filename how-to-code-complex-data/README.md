## [Course](https://learning.edx.org/course/course-v1:UBCx+HtC2x+2T2017)

## 8a. Two One-of Types
- how to design functions with two arguments of *one-of* types?
- concept of "cross product" of the types which helps us define the test cases
## 8b. Local
- introduces the local expression from the Intermediate Student Language
- analogous to variables inside functions in other languages
- teaches how to refactor functions using this new expression to create encapsulation
## 9. Abstraction
- how do we reduce code repetition into helper functions?
- introcudes "fold" functions which are functions based on templates
## 10a. Generative recursion
- until this chapter we work only with structural recursion which means that a base case will be reached from the data definition itself, but in *generative* recursion the proof that we'll reach a base case must be developed by us
- ✨fractals✨
## 10b. Search
- learn to to identify whether a function should be designed using domain knowledge, structural recursion, built-in abstract list functions or generative recursion
- all through the example of the algorithm for solving a Sudoku puzzle
## 11. Accumulators
- what we haven't been able to do so far with recursion is where we have been in the traversal and with the work remaining at each point, accumulators solve these problems
- identify when a function design requires the use of accumulator
- work with the accumulator design recipe to design such functions
- concepts of tail position, tail call and tail recursion
## 12. Graphs