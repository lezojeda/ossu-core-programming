## [Course](https://learning.edx.org/course/course-v1:UBCx+HtC2x+2T2017)

## 8a. Two One-of Types
- how to design functions with two arguments of *one-of* types?
- concept of "cross product" of the types which helps us define the test cases
## 8b. Local
- introduces the local expression from the Intermediate Student Language
- analogous to variables inside functions in other languages
- teaches how to refactor functions using this new expression to create encapsulation
## 9. Abstraction
- how do we reduce code repetition into helper functions?
- introcudes "fold" functions which are functions based on templates
## 10a. Generative recursion
- until this chapter we work only with structural recursion which means that a base case will be reached from the data definition itself, but in *generative* recursion the proof that we'll reach a base case must be developed by us
- ✨fractals✨
## 10b. Search
- learn to to identify whether a function should be designed using domain knowledge, structural recursion, built-in abstract list functions or generative recursion
- all through the example of the algorithm for solving a Sudoku puzzle
## 11. Accumulators
## 12. Graphs